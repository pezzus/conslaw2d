\section{Conclusioni}
Lo schema a Volumi Finiti \eqref{eq:schemavolumifiniti} presenta caratteristiche molto particolari rispetto, per esempio, ad uno schema ad Elementi Finiti per la risoluzione di problemi ellittici.

La struttura è molto semplice ed intuitiva, nonché di semplice implementazione una volta che si ha a disposizione un buon gestore della mesh. Inoltre l'estensione al caso multidimensionale è praticamente automatica, se non per alcuni dettagli riguardanti la geometria. Al contrario un codice FEM presenta certamente difficoltà aggiuntive dovute alla presenza di integrazione numerica, costruzione di matrici sparse, risoluzione di sistemi lineari, e via discorrendo.

Il problema principale però è che sistemi iperbolici tipo Eulero sono estremamente più complessi rispetto a problemi ellittici e parabolici, e tutta questa complessità si riflette poi nelle soluzioni approssimate generate dal metodo numerico. Infatti nei sistemi iperbolici la regolarità delle soluzioni è una questione spinosa, proprio perché manca il termine diffusivo che tende a smussare le discontinuità. Il metodo dei Volumi Finiti, di ordine basso per via dell'approssimazione costante a tratti della soluzione, è adatto quindi dove la regolarità della soluzione non consente un ordine elevato di convergenza, mentre mostra i suoi limiti dove invece la soluzione è più regolare.

Nel problema Shock Bubble molti dettagli non sono stati colti adeguatamente. Eventuali modifiche per migliorare questo aspetto possono però andare in queste direzioni:
\begin{itemize}
\item \emph{Adattività di griglia}, che permetterebbe di concentrare i nostri sforzi computazionali solo vicino alle discontinuità (o a zone con forti gradienti);
\item \emph{Limitatori di pendenza}, con i quali, attraverso particolari procedure (abbastanza complesse nel caso di griglie non strutturate), si ricostruisce una approssimazione lineare della soluzione in ogni elemento, e si utilizzano poi le tracce al bordo di quest'ultima per calcolare i flussi numerici. La particolarità è che per evitare eventuali oscillazioni spurie dovute alla ricostruzione di ordine più elevato si possono costruire limitatori di pendenza (del tutto analoghi al caso 1D) che attivano la ricostruzione solo se necessario. L'ordine di convergenza del metodo così ottenuto risulterà essere più elevato rispetto a quello originale, almeno lontano dalle discontinuità (ove non si può comunque far di meglio);
\item \emph{Metodo Discontinous Galerkin}, il quale cerca di conciliare i punti di forza del metodo dei Volumi Finiti con quello degli Elementi Finiti. In questo caso la soluzione in ogni elemento è combinazione lineare di funzioni di base, e dunque ad ogni passo temporale e su ogni triangolo si deve risolvere un sistema lineare. Lo scopo di tutto ciò è quello di ottenere una approssimazione migliore utilizzando meno triangoli, almeno nelle zone in cui la soluzione è regolare. Ovviamente la generalizzazione è immediata solo a parole, in quanto diventano necessarie a questo punto procedure per l'assemblaggio delle matrici, per l'integrazione numerica, per l'interpolazione e via dicendo.
\end{itemize}

Da un punto di vista del codice, l'implementazione di queste estensioni non comporta drastiche modifiche allo stesso. Ad esempio per il metodo Discontinous Galerkin si possono estendere le classi \texttt{BasePolygon} e \texttt{BaseHEdge} in modo tale che siano disponibili dei metodi per l'integrazione sul poligono o sul lato. Per la risoluzione del sistema lineare si può ricorrere a classi esterne di algebra lineare\footnote{Il codice fa uso della libreria \texttt{Eigen} (\url{http://eigen.tuxfamily.org}), la quale mette a disposizione una vasta gamma di classi e metodi per l'algebra lineare.}, richiamate poi direttamente dal solutore. Anche i limitatori di pendenza richiedono poche modifiche strutturali.

Per quanto riguarda l'adattività di griglia invece possono esserci più problemi, perché in questo caso (a meno di rigenerare ogni volta la mesh da zero) si deve metter mano alla struttura dati. Eliminare un triangolo per poi aggiungerne di più piccoli non è certamente una procedura efficiente, piuttosto si dovrebbe lavorare direttamente sui puntatori della struttura dati.

Nello sviluppo del codice si è optato per un largo utilizzo di \emph{templates}, in modo da ottimizzare il più possibile il codice ed allo stesso tempo mantenere un buon livello di astrazione. Questa scelta ha reso lo sviluppo molto problematico e lento, soprattutto per quanto concerne la gestione della mesh, ma ha poi permesso uno sviluppo del solutore molto più rapido ed intuitivo.

Tra le scelte un pò meno lungimiranti nello sviluppo possiamo certamente evidenziare il caso della gestione delle condizioni iniziali e al bordo, che poteva essere affrontata in modo più elegante attraverso l'utilizzo di funtori. Oppure anche la scelta di conservare la soluzione direttamente nella struttura dati del poligono piuttosto che elevare il livello di astrazione definendo delle classi per lo spazio funzionale. Queste scelte sono di pura convenienza, e non trovano una valida giustificazione, se non il fatto che ``così è più semplice''. Inoltre, ogni codice buon Open Source che si rispetti non pone mai la frase ``versione definitiva'' tra le righe del suo sorgente.